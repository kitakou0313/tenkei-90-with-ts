# 問題リンク
- https://atcoder.jp/contests/joi2011yo/tasks/joi2011yo_e

## 考察
- 制約
    - H, W <= 10^3
    - N <= 9
- 要約
    - グリッドの中にスタート地点Sと1 ~ Nまでの値が書かれたグリッドがある
    - Sから1 ~ Nの順に巡る時の最短経路を求めよ
- 考察
    - S -> 1, 1 -> 2 ... N -1 -> Nの最短経路の合計を求める
        - S -> 1でBFS, 1 -> 2でBFS...を繰り返して合計
        - Q. 全体での最短経路は各途中経路の最短経路の合計と等しいか？
            - A. 等しい
                - 全体での最短経路において、ある区間が最短経路より長いものとする
                - 他区間は最短経路なのでそれ以上全体の区間を短縮できない
        - Q. 数字の昇順以外の順番で巡る方が経路が短縮されるケースがあるか？
            - A. ない
                - 現在のゴールに書かれた値以上のグリッドについても素通りしかできない -> 影響しない
        - Q. ある区間での行動の結果が他の区間の経路を短縮するようなことはあるか？
            - 最短経路以外を通ることが全体的な経路の削減につながるか
            - A. ない
                - 現在の目標グリッドに書かれた値よりも大きい値が書かれたグリッドを通過してもできることがない
        - 実装の詳細
            - 前提
                - Sは0の値が書かれたマスとする
            - 準備
                - Sとチーズ工場の座標を求めてマップにする
                - 最短距離の合計をまとめる変数
            - 以下、goalを1 ~ Nまでループ
                - goal-1 -> goalまでの最短距離をBFS
                    - 準備
                        - goal-1の座標、goalの座標をマップから取得
                        - Queueを初期化
                        - 追加済み座標をまとめるSetを初期化
                        - goal-1から各座標への最短距離をまとめるマップを定義
                    - BFS
                        - goal-1の座標をQueueに追加
                        - goal-1の座標を追加済みSetに追加
                        - goal-1の座標への最短距離を0として追加
                        - 以下をQueueが空になるまでループ
                            - Queueから現在の座標を取得
                            - 現在の座標の隣接（上下左右）座標について、以下の処理
                                - 有効な座標か確認
                                - 探索済みでないか確認
                                - 障害物ではないか確認
                                - 隣接座標をQueueに追加
                                - 隣接座標を追加済みSetに追加
                                - 隣接座標への最短経路を以下の値で更新
                                    - 現在の座標への最短距離 + 1
                - goal座標の最短距離を最短距離の合計をまとめる変数に加算
            - 最短距離の合計をprint


## メモ
- 抽象化せず設定をそのままなぞったほうがわかりやすく考察を記述できることがある
    - グリッドとかかずチーズと書くべきだった

## ToDo

## 解説